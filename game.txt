行。下面是你（主程）的一天执行清单：按顺序做，别跳。每一步都有“完成标准”，你照着打勾就行。

你（ME）主程任务清单（One-Day Build）

0. 开工前 10 分钟（准备）

* 建 repo（或本地项目）+ 基础目录

  * client/
  * server/
  * data/
  * assets/
* 确认局域网：两台机器同 Wi-Fi
  完成标准：你能在另一台机器 ping 到主机（可选）/ 或至少同网段

1. 先把 Server 跑起来（最小联机骨架）
   目标：能创建房间、加入房间、看到玩家列表

* Node + socket.io server
* 房间逻辑：

  * create → 返回 roomCode
  * join(roomCode) → 加入成功/失败
  * roomState 广播：players[], phase
    完成标准：两台电脑打开网页，能 join 同一个 room，双方都看到“对方已加入”

2. Client 最小可用（不管美术）
   目标：浏览器里能输入房间码 → join → 显示房间状态

* Phaser 项目启动（Vite dev server 或静态 server）
* Scene 切换（最简）：

  * LobbyScene：输入框/按钮（先丑也行）
  * RoomScene：显示 roomCode + player list + Ready
    完成标准：你能从 Lobby 进 Room，看到 player list 会更新

3. 状态机（Phase）先做死（别拖）
   目标：房间 ready 后能进入 PREROUND 倒计时

* phase：

  * LOBBY / READY / PREROUND / ROUND / END
* Server 决定 phase，并广播：

  * phase:start {phase, duration}
* Client 只显示倒计时文字
  完成标准：两人 ready → 自动进入 PREROUND（15s）→ 时间到自动进 ROUND（先不开移动也行）

4. Spell 系统（先做 1 个跑通）
   目标：按键施法 → 双方都看到同样的法术效果

* spell 数据从 data/spells.json 读（先硬编码 1 个也行，下午再换）
* client 发：spell:cast {spellId, aimDir}
* server 广播：spell:event {casterId, spellId, seed}
* client 收到 spell:event → spawn projectile（本地模拟即可）
  完成标准：A 放一次法术，B 必定看到同样的投射物出现/飞行/消失

5. PREROUND 只允许施法（禁移动）
   目标：你提出的“开始阶段禁移动”落地

* 在 PREROUND：

  * 不发送 player:input
  * 或 server 忽略 movement（推荐 server 忽略）
    完成标准：PREROUND 期间角色不会动，但能放法术

6. 加到 2–3 个法术（模板复用）
   目标：法术数量够 demo

* 复用同一套 projectile 模板，只改参数：

  * speed / lifetime / spread / count / damage
    完成标准：至少 2 个法术可稳定释放且同步

7. 语音 → spellId（最简单版本 + fallback）
   目标：语音是亮点，但不影响 demo

* Web Speech API
* 识别文本 → normalize → keywords.json alias 匹配
* 成功后直接 castSpell(spellId)
* 按键 1/2/3 作为 fallback
  完成标准：你说 10 次，至少成功 6 次；失败也能用按键继续 demo

8. 接入 Sam 的地图（Tiled）
   目标：看起来像“像素独立游戏”

* 加载 arena.json + tileset.png
* 创建 Ground layer + Collision layer
* 玩家/投射物碰撞（最简单：投射物碰撞 tile 就消失）
  完成标准：角色能站在地面上（哪怕暂时不移动），场景不空白

9. 接入 UI 皮肤（Sam/Ivan 的 ui_panel/icons）
   目标：去掉“网页味”

* 用 ui_panel 做：

  * 房间面板
  * 字幕面板
  * HP 框
    完成标准：屏幕上不出现 HTML 按钮风格，整体像游戏 HUD

10. 封板 + Demo 演练（17:00 后只修不加）
    目标：不翻车

* 固定 demo 路线：

  * Create room → Join → Ready → PREROUND（语音施法展示）→ ROUND（移动可选）→ End
    完成标准：连续跑 3 次 demo 不崩、不丢连接、不黑屏

关键约束（你必须遵守）

* 上午优先联机+房间流程（没这个全死）
* 法术最多 3 个（先稳再加）
* 17:00 后不加功能，只修 bug
* 任何新点子进 ARCHIVE，不实现

如果你告诉我：你准备用“Phaser + Vite + TS”还是“Phaser + JS（无 TS）”，我可以把第 1–3 步的项目骨架（目录 + npm scripts + 最小 socket 连接）也给你一套“照抄就能跑”的版本。




、你这个游戏“现在是什么样子”（定型版）
类型

2D 像素风

竞技场式法师对战

1v1（局域网联机）

偏独立游戏气质，不是网页小游戏

运行方式

浏览器打开就能玩

同一 Wi-Fi 下：

一个人 Create 房间

另一个人输入 Room Code 加入

不下载、不安装、不注册

核心玩法

玩家进入同一个房间
（然后预留一个选项说是  以后故事模式的   程序也要做铺）

游戏开始前有一个 施法准备阶段

不能移动

只能施法

用语音说咒语（比如 wagalona）

正式对战阶段：

可以移动

继续施法

法术实时同步到对方屏幕

一方 HP 归零 → 结束



法术系统（重点卖点）

5–8 个法术（以 5 个为稳）
然后法术是消耗魔力的）

法术由 配置文件驱动

不是点技能按钮，而是：

说咒语

语音识别 → spellId

触发对应法术

失败了     就是说的过程会显示可能的   和识别到的东西


画面风格

像素风（16×16 tile）

Tiled 做的竞技场地图

有层次：

背景

地形

碰撞

UI 是像素面板（不是 HTML 按钮）

整体感觉更像：

独立像素游戏

而不是网页/网游

技术形态（你心里要非常清楚）

Client：Web（Phaser 3）

Server：Node.js + socket.io

Server 决定：

房间

阶段（Lobby / Pre-round / Round）

法术事件

Client 负责：

画面

输入

语音

播放效果